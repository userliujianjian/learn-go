## 如果对齐的内存写入是原子的，为什么我们需要`sync/atomic`包？

这是一篇受Go论坛上一个问题启发的[帖子](https://forum.golangbridge.org/t/go-test-race-and-uint8-variables/7707)。转述的问题是，“如果处理器保证正确对齐的写入时原子的，为什么竞争检测器会抱怨？”。

答案是：“原子”这个词有两种用法。第一个，即OP（TODO:什么是OP?）引用的那个，是大多数微处理器的一个属性，只要写入的地址自然对齐--比如说，如果它是一个32位值，那么它总是被写入一个地址，该地址是4的倍数--那么什么都不会观察到一半的写入值。  

为了解释这意味着什么，请考虑相反的情况，即不对齐的写入，其中32位值被写入地步两位不为零的地址。在这种情况下，处理器必须将写入操作拆分为两部分，跨越边界。这称为撕裂写入，因为总线上的观察者可以看到此部分更新的值。  

这些词来自多个处理器普级之前的时代。此时读取或写入损坏的观察者很可能是ISA、VESA或PCI总线上的其他代理，如磁盘控制器或视频卡。然而，我们现在生活在多核时代，所以我们需要谈谈缓存的可见性。

在现代多处理器系统中，对朱内存的写入将在达到朱内存之前缓冲在多级缓存中(CPU的L3缓存)。这样做是为了隐藏主内存的延迟，但这样做意味着使用主内存的处理器之间的通信存在不精确现象；从内存中读取的值可能已被另一个处理器覆盖，但新值尚未通过各种缓存。  

要解决这种歧义6，您需要使用内存围栏，也称为内存屏障。内存写入屏障操作告诉处理器，它必须等到其管道中的所有未完成操作（特别是写入操作）都已刷新到主内存。此操作会使缓存失效。  

有其他处理器持有，迫使它们直接从内存中检索新值。读取也是如此，您可以使用内存读取屏障来告诉处理器停止并与任何未完成的内存写入同步。  

就Go而言，读取和写入内存屏障操作由sync/atomic包处理，具体来说，分别是atomic.Load和atomic.Store函数系列。  

- 在回答OP的问题时：为了安全地使用内存中的值作为两个goroutine之间的通信通道，除非使用sync/atomic包，否则竞争检测会报错。  
	- 从历史上看，大多数微处理器（尤其是英特尔）***将未对齐的写入定为非法***，如果尝试未对齐的读取或写入，则会导致故障。在晶体管价格昂贵的时代，这简化了处理器的设计，消除了对齐的负载和存储器子系统的严格对齐要求。然而，今天，几乎所有的微处理器都已经发展到允许不对齐的访问，但代价是性能和原子写入属性的损失。  
	- 第一台具有缓存功能的生产计算机时IBM System/360 Model 85。  
	- 这是一种过度简化。在硬件级别，物理地址范围需要取消缓存以进行读取，或者遵循直写语义，而不是回写语义。对于同一虚拟地址空间中两个goroutine之间的内存可见性的理论，可以安全地忽略这些细节。  
	- 吹毛求疵者注：从技术上讲，缓存行是无效的。  
	- 尽管大多数处理器允许对未对齐的读取和写入，但内存上的原子操作要求地址自然对齐，因为处理器之间的通信由缓存处理，缓存根据通常为64字节长的缓存进行操作。***因此未对齐的读取或写入可能跨越两条缓存行，这不可能在处理器之间进行原子同步***。  

#### 参考文章：
- [原文：对齐的内存写入是原子的嘛？](https://dave.cheney.net/2018/01/06/if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package)  

- [堆栈跟踪和错误包](https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package)  
- [如何在GO包中包含C代码](https://dave.cheney.net/2013/09/07/how-to-include-c-code-in-your-go-package)  
- [为什么我认为Go包管理很重要](https://dave.cheney.net/2013/10/10/why-i-think-go-package-management-is-important)  
- [Go不带包范围的变量](https://dave.cheney.net/2017/06/11/go-without-package-scoped-variables)  
- 