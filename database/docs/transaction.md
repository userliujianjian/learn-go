### 数据库事物

### 介绍
- 数据库是指多个数据库操作组成一个逻辑执行单元，满足ACID四个条件
	- A: 原子性，即这些操作要么全成功要么全失败，不存在中间状态
	- C: 一致性，数据库从一个状态转移到另一个状态，数据完整性约束不变。在分布式语境下，这个很多时候是指数据如果存储了多份，那么每一份都应该是一样的（后面分布式语境，要小心一点，因为这一步，kennel面试官准备考察分布式事务）
	- I: 隔离性： 一个事物的执行不会影响另外一个事务
	- D：持久性：已提交对数据库的修改，应该永久保存在数据库中。装逼点：而实际上mysql的事务，如果设置不当，可能出现事务已提交，但是并没有被持久化。（这点是为了加分的，需要记住后面的--》事务提交了但是数据没保存）

在MYSQL上，innodb引擎支持事务，但是MyISAM不支持事务。（这个是为了引导面试官问两个引擎的区别）

innodb引擎是通过mvcc来支持事务的（到了这一步先停下来，接下来，面试官大概率会问你什么事mvcc）
- 关键点：ACID， innodb通过mvcc支持事务

### 扩展点

#### 什么事MVCC？
- 分析：
	mvcc算是一个常考的点，而且是一个能考察的很细很深入的点，这里我们尽量将话题控制在一个难度适中的地步。当然，如果你是DBA，那么你应该一路往下探讨直到源码曾。这个问题得非常的大，所以我们只需要回答要点就可以。然后，面试官如果想继续了解你的水平，他就会根据他感兴趣的点问下去。这里的难点就太多...要背很多
- 答案：
	- MVCC，多版本并发控制。innodb引擎主要是通过undo log和事物版本好来实现多版本，利用锁机制来实现并发控制。
	（接下来仔细解释undo log和版本号的运作机制，其中undo log是为了引导面试官继续问相关问题，如redo log，bin log）
	- innodb引擎会给每张表加一个隐含的列，存储的是事物版本号。当修改数据的时候，会生成一条对应的undo log，undo log一般用于事物回滚，里面含有版本信息。简单来说可以认为undo log存储了历史版本数据。每当发起查询的时候，mysql依据隔离级别的设置生成Read view，来判断当前查询可以读取那个版本的数据。例如，在已提交读的隔离级别下，可以从undo log中读取到已经提交的最新数据，而不会读取到当前正在修改尚未提交的事务数据。

	- 而锁机制，对于innodb来说有多个维度：
		- 从独占性来说，有排它锁和共享锁
		- 从锁粒度来说，有行锁和表锁
		- 从意向来说，有排它意向锁和共享意向锁
		- 从场景来说，有记录锁，间隙锁，临键锁
- 分析： 到这里停下来，上面这一番回答，基本什么都点到了，接下来就是等提问，这一堆答案，涉及到了很多知识点，可以考察的非常多：
	- undo log, redo log, binlog
	- 隔离级别
	- 各种锁，其中又以记录锁、间隙锁和临键锁比较有亮点
	- read view
- 关键点：多版本 = undo log + 事务版本号，并发控制 = 各种锁
- 如何引导： 
	讨论数据库事物隔离级别

#### 能够解释一下MYSQL的隔离级别嘛？
- 分析：
	- 考察基本的知识点。如果只是背出来各种隔离级别和对应存在的问题，那么就达标了。
	- 刷两点如何刷呢？一个是结合MVCC阐述Mysql是如何支持的；一个是讨论snapshot isolation。前者比较中规中矩，后者较多的是秀知识面。
	- 我们分成两个思路，前面都累死，就是总结各种隔离级别
- 答案： 
	- 数据库的隔离级别有四种：
		- 未提交读：事务可以读取到另一个事务没有提交的数据。问题：脏读，不可重复读，幻读
		- 提交读：事务职能读取到另一个已提交的事务数据。 问题：不可重复读，幻读
		- 可重复读：事务执行过程中查询结果是一致的，innodb 默认级别。 问题： 幻读
		- 串行化：读写都会相互阻塞问题
	- MVCC方向： innodb引擎利用了Read view来支持提交读和重复读。Read view里面维护这三个变量：
		- up_limit_id:已提交事务ID
		- low_limit_id: 最大事务ID
		- txn_ids: 正在执行事务id。
		提交读这个级别，默认读取是不加锁的，只有修改才会加锁。简单说，已提交读，是每次查询都生成一个新的Read View，所以永远都能看到已提交事务。  

		可重复读则是在第一次查询生成Read view后，后面的查询都是使用这个Read View。
	- snapshot isolation方向： 
		- innodb引擎的可重复读隔离级别，要比定义的隔离级别更加严苛一点。 一般的可重复读，无法解决幻读的问题。比如说原本你事务里面查询订单信息，这个时候有插入了一个新的订单，那么这种时候，幻读就会导致我们下一个查询就会查询到这条记录。但是innodb引擎的隔离级别并不会出现问题。

		- 因为innodb引擎使用了临键锁，在当前读，也就是写的时候，锁住了记录之间的空档，放置插入数据。（这里面不需要解释临键锁，等面试官问）

- 如何引导：
	- 前面聊到了MVCC提到隔离级别，机会合适就可以主动发起进攻

#### 什么是共享锁，排它锁
- 分析： 概念题，答完顺便回答意向排他锁，意向共享锁，刷一波
- 答案：
共享锁指别的事务可以读，但是不可以写。排它锁，是指别的事物既不可以读也不可以写。与之非常类似的是，意向共享锁和意向排它锁，事务在获取共享锁或者排它锁之前，要现货的对应的意向锁。意向锁是数据库自己加的，不需要干预。
> （可能比较绕，记不住就算了） 排它锁和其他三种都互斥；意向排它锁和意向锁兼容；共享锁和意向共享锁兼容

#### 什么是记录锁，临键锁，间隙锁
- 分析： 概念题，可以点出来记录锁和行锁的关系，并指明一下行锁在索引项上加的。  
- 答案：
	- 记录锁：锁住一行，所以叫记录锁，也是行锁。
	- 间隙锁：锁住记录之间的间隔，或者索引之前或之后的范围。之灾重复读级别产生。
	- 临键锁：记录锁和间隙锁的组合，即锁住记录，又锁住了间隙。  

#### innodb与MyISAM引擎的区别
- 分析： 
	很多人陷入一个误区，就是死记硬背所有的区别，面试的时候一紧张，又忘了。其实大可不必，记住几个关键点就可以了，因为面试官不一定把所有的点都记得。说实在，这个问题完全是为了面试而面试，因为在当前大家选择mysql一般都默认使用innodb引擎的时候，讨论这个区别没有太大实际意义。玩意不行的是你们公司用的是MYISAM引擎，就要仔细回答，方方面面照顾到。

- 答案：innodb引擎和MyISAM引擎最大的区别是事务、索引、锁支持。
	- innodb引擎支持事务，MyISAM不支持。
	- innodb引擎的主键索引的叶子节点存放的是数据本身，MyISAM存储的是数据地址，需要再一次寻址。
	- innodb支持行锁，而MyISAM支持表锁，因此innodb支持的并发力度更细更高。

	一般来说，在不使用事务，数据修改少而读多的时候，又或者机器比较差的时候，用MyISAM比较合适。

#### 为什么事务提交了但是数据没有保存
- 分析
	这个问题呢，因为它和ACID的特性有冲突，所以是一个装逼点。一般不做 DBA，没踩过这一类的坑的人，比较容易忽略这一点。在前面提到 ACID 的 D 的时候，如果你记得这个，就可以主动说。整体来说，这是一个稍微高级一点的话题，所以要把握尺度，对这方面了解比较深刻，就一定要刷一波；如果感觉对面的面试官了解不深，也可以刷一波
- 答案：
	- 在MySQL的innodb引擎中，事务提交后，必须将数据刷盘到磁盘上，如果在事务提交之后，没来得及刷到磁盘，就会出现事务已经提交，但是数据丢失了。（回到这一步你要开始判断，如果你是主动聊的，那就停下来，等面试官追问；如果这是面试官问的，那就接着答细节）
	- MySQL的innodb引擎，事务提交的关键是将redo log写入到Log buffer，而后MySQL调用write写入到OS cache，只有到最后操作系统调用fsync的时候，才会落到磁盘上。

	- 为了方便记忆，记住这个过程：commit -> log buffer -> OS cache -> fsync
	- 数据库有一个参数 innodb_flush_log_at_trx_commit 可以控制刷盘的时机：
		- 0: 写到log buffer，每秒刷新
		- 1: 实时刷新
		- 2：写到os cache，每秒刷  
	接下来步入终极装逼环节，为了表达我们对这个问题的深刻理解，对OS的一般理解，我们得扩充一下回答面，慎用

	- Redis的AOF机制也面临类似的问题，即AOF也不是立刻刷盘，而是写入到了OS cache，等到缓冲区填满，或者Redis决定刷盘才会刷到磁盘。而redis有三种策略控制，always 永远, everysec 每秒, no 不主动。默认情况下everysec，即有一秒钟的数据可能丢失。

	- （最后升华一下主题） 对于大多数要和磁盘打交道的系统来说，都会面临类似的问题，要么选择性能，要么选择强持久性。

- 关键字：提交不等于落盘，fsync

#### 什么是redo log, undo log 和 binlog
- 分析：
	概念题。最好的回答是用undo, redo, binlog来讲述清楚事务与回滚，主从同步复制。这里我们做一个简要的回答，把精髓答出来

- 答案：
	- redo log 是innodb引擎产生的，主要用于支持MySQL事务，MySQL会先写redo log，而后在写binlog。redo log可以保证即使数据库异常重启，数据也不会丢失
	- undo log 是innodb引擎产生的，主要时候用于解决事务回滚和MVCC。数据修改的时候，不仅记录redo log，也会记录undo log。在事务执行失败的时候，会使用undo log进行回滚；
	- binlog 主要用于复制和数据恢复，记录了写入性的操作。binlog分成基于语句，基于行和混合模式三种复制模式。
	- （扩展点1，阐述两阶段提交） 因为redo log生成到binlog写入之间有一个时间差，所以为了保证两者的一致性，MySQL引入了**两阶段提交**:
		- Prepare阶段，写入redo log；
		- Commit阶段，写入binlog，提交事务；
	- 扩展点2，阐述一下输盘时机：
		- binlog 刷盘可以通过sync_binlog参数来控制。0-系统自由判断，1-commit刷盘，N-每N个事务刷盘
		- redo log刷盘可以通过参数innodb_flush_log_at_trx_commit控制。0-写入log buffer，每秒刷新到盘；1-每次提交；2-写入到OS cache，每秒刷盘；

参考文章：https://github.com/flycash/interview-baguwen/blob/main/database/transaction.md


