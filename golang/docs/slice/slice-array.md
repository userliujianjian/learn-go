### 数组与切片

- 数组的长度是类型的一部分，声明后不可更改。(ps: `[3]int`和`[4]int`是同类型嘛？)
- slice切片是一个拥有相同元素类型的可变长度的序列。它是基于数组类型做的一层封装。非常灵活支持自动扩容。

源码定义如下：
```go
type slice struct {
	array unsafe.Pointer // 元素指针
	len int // 实际元素个数
	cap int // 容量
}
```


我们在编码的过程中有没有遇到一些不可思议的事，下面让我们看一个例子：
```go
func SliceTest() {
	slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s1 := slice[2:5] // 从下标2开始，到下标5结束，不包含5
	// 从s1的下标2开始，到下标6结束，不包含6， 容量到下标7
	//  slice[4:8:9] 与s2有什么区别
	s2 := s1[2:6:7]

	s2 = append(s2, 100)
	s2 = append(s2, 200)

	s1[2] = 20
	fmt.Println("SliceTest start.....")

	fmt.Println(s1) // [2 3 20]
	fmt.Println(s2) // [4 5 6 7 100 200]
	fmt.Println(slice) // [0 1 2 3 20 5 6 7 100 9]
	fmt.Println("SliceTest end.....")
}

```
让我们来分析下上面的代码  
`s1`从`slice`索引2(闭区间)开始到索引5（开区间，元素真正索引到4），长度为3，容量(cap)默认到数组结尾为8  
`s2`从`s1`的索引2闭区间到索引6（开区间，元素真正取到5），容量所引到7，为5
![1](../img/slice-var-1.png)  
接着，向`s2` 尾部追加一个元素100:
```go
s2 = append(s2, 100)
```
s2容量刚刚够，直接追加，不过这会修改原是数组对应位置的元素。这一改动，数组和`s1`都可以看得到。  
![2](../img/slice-var-2.png)  
再次向`s2` 追加元素200:
```go
s2 = append(s2, 200)
```
这时，`s2`的容量不够用，该扩容了，于是 `s2` 另起炉灶，将原来的元素复制到新的位置，扩大自己的容量。并且为了应对未来可能的append带来再次扩容，`s2` 会在此次扩容时多留一些buffer，将新的容量扩大为原始容量的2倍，也就是10.
![3](../img/slice-var-3.png)  

最后，修改`s1`索引位为2位置的元素
```go
s1[2] = 20
```
这次只会影响原是数组相应位置的元素。它影响不到`s2`了，因为s2扩容后重新创建新的地址了
![4](../img/slice-var-4.png)  

载体一点，打印`s1`的时候，只会打印出`s1`长度以内的元素。所以只会打印出3个元素，虽然他的底层数组不止3个元素。

#### 课后总结
- 数组与切片有什么区别呢？
- 函数的参数为切片，在函数内修改后，对函数外的切片变量有影响嘛？
- 同上参数为数组呢？

参考文章：
https://golang.design/go-questions/slice/vs-array/
