## Go内存模型（这一节没理解，之后补充）

### 介绍
Go内存模型制定了在一个goroutine中读取变量时可以保证观察在不同gotoutine中写入统一变量所产生的值的条件

### 建议
- 修改多个goroutine同时访问的数据程序必须序列化此类访问。
- 要串行化访问，请使用通道操作或其他同步原语(例如sync和sync/atomic包中的同步原语)保护数据。
- 如果您必须阅读本文档的其余部分才能了解程序的行为，那么您就太聪明了
- 别自作聪明

#### 非正式概述
Go的内存模型处理方式与该语言的其他部分大致相同，旨在保持语义简单、易于理解和游泳。本节提供了该方法的总体概述，对于大多数程序猿足够了。  

数据竞争本定义为对内存位置的写入与对同一位置的另一次读或写入同时发生，除非涉及的所有访问都是包提供的原子数据访问sync/atomic。如前所述，强烈鼓励程序员使用适当的同步来避免数据争用。在没有数据竞争的情况下，Go程序的行为就像所有goroutine都复用到单个处理器上一样。此属性有时称为DRF-SC：无数据争用程序以顺序一致的方式执行。  

<br>
虽然程序员应该编写没有数据竞争的Go程序，但Go实现在响应数据竞争方面可以做的事情是有限的。实现总是可以通过报告竞争并终止程序来对数据竞争作出反应。否则，每次读取单子接大小或子字节大小的内存位置都必须观察实际写入位置的值(可能是通过并发执行的goroutine)且尚未被覆盖。这些实现限制使用Go更像JAVA或javascript，因为大多数竞赛的结果数量有限，而不想c和C++，其中任何具有竞争程序的含义完全为定义，并且编译器可以做任何事情。Go得到方法旨在使错误的程序更可高、更容易调试，同时仍然坚持认为竞争是错误，并且工具可以诊断和报告它们。
<br>

### **内存模型**
内存模型描述了程序执行的要求，程序执行由goroutine执行组成，而goroutine执行又由内存操作组成。  
- 内存操作由四个细节建模：  
	- 它的种类，表明是普通数据读取、普通的数据写入，还是原子数据访问、护持操作、通道操作等同步操作
	- 它在程序中的位置
	- 正在访问的内存位置或变量
	- 操作读取或写入的值

一些内存操作是类似读取的，包括读取、原子读取、互斥锁和通道接收。其他内存操作是类似写入的，包括写入、原子写入互斥锁解锁、通道发送和通道关闭。有些例如原子比较和交换，既是读的又是写的。  
GOroutine执行建模由单个goroutine执行的一组内存操作。  
- 要求（TODO：可以看看原文）

### 示例
- **Goroutine创建**
启动新的goroutine语句，go在goroutine开始执行之前同步。 如下
```go
var a string
func f(){
	print(a)
}

func hello(){
	a = "hello, world"
	go f()
}
```
调用将在将来的某个时刻打印hello（也许是返回之后）

- **Goroutine破坏**
Goroutine的退出不保证在程序中的任何事件之前同步。 例如：
```go
var a string
func hello(){
	go func() {a = "hello"}()
	print(a)
}
```
对变量a的赋值后面没有任何同步事件，因此不能播阿政任何其他goroutine都会观察到它。事实上，激进的编译器可能会删除整个go语句。  
如果一个goroutine的效果必须右另一个goroutine观察，请使用同步机制（例如锁或通道通信）来建立相对顺序。 

- **渠道沟通**  
通道通信是goroutine之间同步的主要方法。特定通道上的每个发送都与该通道的响应接收相匹配，通常在不同的goroutine中。
痛啊都山歌发送在完成来自该通道的相应接收之前同步。 

```go
var c = make(chan int, 10)
var a string

func f(){
	a = "Hello, world"
	c <- 0
}

func main(){
	go f()
	<- c
	print(a)
}
```
保证打印“hello, world”。写入a在发送之前排序c，发送在响应的接受完成之前同步c，而接受完成在print之前排序。  
通道的关闭在接收返回零值之前同步，因为通道已关闭。

在前面的示例中，体检 c<- 0为close(c)会产生具有相同保证行为的程序。
来自无缓冲通道的接收在该通道上响应的发送完成之前进行同步。   
该程序（如上所述，但交换了发送和接收语句并使用无缓冲通道）  
```go
var c = make(chan int)
var a string

func f(){
	a = "hello , world"
	<- c
}

func main(){
	go f()
	// 无缓冲通道，具有可靠性交付的特性，√√发送完成在接收之前发生
	c <- 0
	print(a)
}

```
保证打印"hello, world". 写入a在接收发之前排序c， 接收在响应饿发送完成之前进行同步c， 而发送完成在print之前。  
如果通道被缓冲(例如 c = make(chan int, 1)), 则程序无法保证打印"hello, world"(它可能会打印空字符串、崩溃或执行其他操作。)。
容量为c的通道上的第k个接收，在该通道的第k+c个发送完成之前同步。  

该规则将先前的规则推广到缓冲通道。 它允许通过缓冲通道对计数信号量进行建模： 通道中的项目数对应于活动的那个使用的数量，通道得到容量对应于同时使用的最大的数量，发送项目获取信号量，并且接收到一个项目会释放信号质量。这是限制并发的常见习惯用法。   
该程序为工作列表中每个条目启动一个goroutine，但goroutine使用通道进行协调limit，以确保一次最多有三个正在运行的工作函数。
```go
var limit = make(chan int, 3)
func main(){
	for _, w := range work{
		go func(w func()){
			limit <- 1
			w()
			<- limit
		}
	}
	select{}
}
```

- **锁(Locks)**
该sync包实现了两种锁类型，sync.Mutex和syncRWMutex。
<br/>
对于任何sync.Mutex or sync.RWMutex变量l 且n < m, 调用n会在调用调用m 返回l.Unlock()之前同步  

```go 
var lsync.Mutex
var a string

func f(){
	a = "hello, world"
	l.Unlock()
}

func main(){
	l.Lock()
	go f()
	l.Lock()
	print(a)
}
```
保证打印“hello world”, 对l.Unlock() 的第一次调用在第二次调用返回之前同步，第二次调用在 l.Lock() main print


#### 参考原文
https://go.dev/ref/mem











